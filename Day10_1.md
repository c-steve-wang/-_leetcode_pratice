# 代码随想录Day10

leetcode 232, 225, 20, 1047

## [leetcode 232](https://leetcode.com/problems/implement-queue-using-stacks/)

这个地方我能想到怎么做，但是用python实现确实是个问题
然后要注意面向对象的思想，已经定义过的函数就应该直接用

```Python
class MyQueue:

    def __init__(self):
        self.stack_in = []
        self.stack_out = []
        

    def push(self, x: int) -> None:
        self.stack_in.append(x)
        

    def pop(self) -> int:
        if self.empty():
            return None
        
        if self.stack_out:
            return self.stack_out.pop()
        else:
            for i in range(len(self.stack_in)):
                self.stack_out.append(self.stack_in.pop())
            return self.stack_out.pop()
        

    def peek(self) -> int:
        ans = self.pop()
        self.stack_out.append(ans)
        return ans
        

    def empty(self) -> bool:
        return not (self.stack_out or self.stack_in)

```

## [leetcode 225](https://leetcode.com/problems/implement-stack-using-queues/)

这个地方第一时间没反应上来，而且对python中deqeue也不是很熟悉，这个题不难理解但是要认真学习啊
先记录一个直接用双端队列的偷懒写法

```Python
class MyStack:

    def __init__(self):
        self.que = deque()
        

    def push(self, x: int) -> None:
        self.que.append(x)
        

    def pop(self) -> int:
        return self.que.pop()
        

    def top(self) -> int:
        if self.empty():
            return None

        return self.que[-1]
        

    def empty(self) -> bool:
        return not self.que
```

然后才是正常的用单端队列的解法
```Python
class MyStack:

    def __init__(self):
        self.que = deque()
        

    def push(self, x: int) -> None:
        self.que.append(x)
        

    def pop(self) -> int:
        if self.empty():
            return None
        for i in range(len(self.que)-1):
            self.que.append(self.que.popleft())
        return self.que.popleft()
        

    def top(self) -> int:
        if self.empty():
            return None
        for i in range(len(self.que)-1):
            self.que.append(self.que.popleft())
        ans = self.que.popleft()
        self.que.append(ans)
        return ans
        

    def empty(self) -> bool:
        return not self.que
```

